<b><u>CACM-2265</u></b><br /><b>A Model for Type Checking</b><br />in particular a program is mapped into an expression  within a decidable subset of the lambda calculus which characterizes the <b>type</b> relations within the program  and eliminates all other information .<b>type</b> checking <b>types</b> lambda calculus models for programming languages syntax semantics compiler  writing language implementation formal definition  4 .a model for <b>type</b> checking  most current programming languages treat computation over different classes of objects e .<br /><b><u>CACM-2957</u></b><br /><b>Database Abstractions: Aggregation</b><br />aggregation transforms a <b>relationship</b> between objects into a higher-level object .a new <b>data</b>  <b>type</b> called aggregation is developed which under certain criteria of well-definedness specifies  aggregation abstractions .<b>data</b> abstraction relational database <b>data</b> <b>type</b> aggregation database design <b>data</b> structure  knowledge representation <b>data</b> definition language  3 .<br /><b><u>CACM-3105</u></b><br /><b>A Language Extension for Expressing Constraints on Data Access</b><br />programming languages access control <b>data</b> <b>types</b> abstract <b>data</b> <b>types</b> <b>type</b> checking capabilities  4 .the constraints are stated declaratively and can  be enforced by static checking similar to <b>type</b> checking .a language extension for expressing constraints on <b>data</b> access  controlled sharing of information is needed and desirable for many applications and is supported  in operating systems by access control mechanisms .<br /><b><u>CACM-2956</u></b><br /><b>Some Ideas on Data Types in High-Level Languages</b><br /><b>data</b> <b>types</b> generic procedures programming languages  4 .some ideas on <b>data</b> <b>types</b> in high-level languages  a number of issues are explored concerning the <b>notion</b> that a <b>data</b> <b>type</b> is a set of values together  with a set of primitive operations on those values .among these are the need for a notation for iterating  over the elements of any finite set instead of the more narrow for i 1 to n notation the use of  the domain of an array as a <b>data</b> <b>type</b> the need for a simple notation for allowing <b>types</b> of parameters  to be themselves parameters but in a restrictive fashion and resulting problems with conversion of  values from one <b>type</b> to another .<br /><b><u>CACM-3142</u></b><br /><b>Consumer Difficulties With Computerized Transactions: 
An Empirical Investigation</b><br />attempts to <b>correct</b> errors often turned out to be difficult and not always successful .consumer difficulties with computerized transactions  an empirical investigation  the prevalence with which errors may be encountered by the  end targets of a computerized <b>process</b> is assessed .how many and what <b>type</b> of errors occur  how easily are they corrected  what is the reaction of consumers to errors-to a failure to <b>correct</b> them  what can be learned by designers of large management packages from such <b>data</b> results show that with the present state of the art approximately 40 percent of individuals or households having average contacts with different <b>types</b> of accounts experience one or more errors per year .<br />